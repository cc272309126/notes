
kernel run path

路径
hardirq
softirq/tasklet
exception
system call
page fault
kernel thread
int3 trap debug

约束
hardirq before ack, cli
hardirq + softirq , mask same irq
hardirq + softirq, not preempt 
hardirq, not preempt by softirq/system call



kernel run path	

1: user program error == exception(dpl=0, sti) -- 20
2: system call  == exception (dpl=3, sti)  -- 300 
3: page fault == exception(dpl=0, sti) -- 1
4: int3 trace/debug == interrupt(dpl=3, cli) -- 3  	
5: device interrupt == interupt(dpl=0, cli) -- 200


nesting

exception --> interrupt/int3
exception -x-> systemcall/pagefault/exception

systemcall --> interrupt/int3/page fault 
systemcall -x-> exception/system call

page fault --> interrupt/int3
page fault -x-> exception/system call/page fault

interrupt --> interrupt/int3
interrupt -x-> exception/system call/page fault

preempt
0|nmi|hardirq|softirq|preemptcount

do not preempt
1: hardirq
2: softirq
3: preemptcount != 0, spinlock/rwspinlock/seqlock/scheduler/percpu

do preempt
preempt == 0  		can/cannot
need_resched == 1	need/neednot

when set need_resched, in hardirq

when check preempt_count
1: exit from hardirq
2: exit from softirq
3: preemptcount change as 0
	exit from spinlock/rwspinlock/seqlock
	exit from scheduler
	exit from percpu



书上说“在中断处理程序中可以使用自旋锁”

那么，假设自旋锁锁定了一个临界区，而且一个进程正在持有该锁，此时发生中断，中断服务函数中又申请该自旋锁，那岂不是会造成死锁，因为中断服务函数在等待自旋锁，但是进程将永远得不到释放自旋锁的机会。

1)
在中断中使用自旋锁时，内核会先禁止本地中断。
当获取spinlock时，要disable interrupt

2)
你所说的引起死锁是有可能发生的，但这需要使用者去保证不要让这种情况发生，如果一个资源可能在中断处理程序中获取，那么获取这种资源，使用自旋锁应该使用spin_lock_irqsave（），禁止中断。而不是spin_lock（）了。


3)
中断具有抢占性，因此本身就可以算是一种锁，因此本身应该lock - 1, 否则任何锁都无法阻止deadlock

中断  -- 具有抢占性  -- 自带lock+1属性
	hard irq
	soft irq -- 都在中断上下文
抢占性的进程 -- 具有抢占性 -- 自带lock+1属性
普通无抢占性进程 -- 没有抢占性 -- lock==0

4)
自旋锁就是为多处理器引入的，可以用在中断中。
当中断中使用某个资源而尝试获取自旋锁时，如果获取不到，它会一直不断尝试自旋；与此同时，等待在其他CPU上运行的进程释放这个资源的自旋锁。也就是说，并不是其他获取这个自旋锁的进程一定要在中断处理的CPU上运行。

