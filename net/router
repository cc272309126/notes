冲突域：在同一个冲突域中的每一个节点都能收到所有被发送的帧
广播域：网络中能接收任一设备发出的广播帧的所有设备的集合
冲突域是基于第一层（物理层）
广播域是基于第二层（链路层）

广播域就是说如果站点发出一个广播信号后能接收到这个信号的范围。通常来说一个局域网就是一个广播域。
局域网 -- 路由器分割的网络

集线器（Hub）设备不能识别MAC地址和IP地址，对接收到的数据以广播的形式发送，它的所有端口为一个冲突域同时也为一个广播域。
交换机设备具有MAC地址学习功能，
通过查找MAC地址表将接收到的数据传送到目的端口，相比于集线器，交换机(Switch)可以分割冲突域，它的每一个端口相应的称为一个冲突域。
交换机虽然能够分割冲突域，但是交换机下连接的设备依然在一个广播域中，
当交换机收到广播数据包时，会在所有的设备中进行传播。

路由器并不通过MAC地址来确定转发数据的目的地址。
路由器工作在网络层，利用不同网络的ID号（IP地址，又称为网络地址、协议地址）来确定数据转发的目的地址。MAC地址通常由设备硬件出厂自带不能更改，IP地址一般由网络管理员手工配置或系统自动分配。
路由器通过IP地址将连接到其端口的设备划分为不同的网络（子网），每个端口下连接的网络即为一个广播域，广播数据不会扩散到该端口以外，因此我们说路由器隔离了广播域。


在二层交换机层面实现逻辑广播域 -- vlan -- 不需要路由器


VLAN生成的逻辑上的交换机是互不相通的。因此，在交换机上设置VLAN后，如果未做其他处理，VLAN间是无法通信的。  

解决VLAN间互通的第一种方法是：为每个VLAN分配一个单独的路由器接口，VLAN间的数据通信通过路由器进行三层路由，这样我们就可以实现VLAN之间相互通信。但是，随着每个交换机上VLAN数量的增加，这样做必然需要大量的路由器接口。出于成本的考虑，一般不可能用这种方案来解决VLAN间路由选路问题。此外，某些VLAN之间可能不需要经常进行通信，这样导致路由器的接口没被充分利用。

为了解决物理接口需求过大的问题，在VLAN技术的发展中，出现了另一种路由器——独臂路由器，用于实现VLAN间通信的三层网络设备路由器，它只需要一个以太网接口，通过创建子接口可以承担所有VLAN的网关，而在不同的VLAN间转发数据。 
如上图所示，路由器仅仅提供一个以太网接口，而在该接口下提供三个子接口分别作为3个VLAN用户的缺省网关，当VLAN100的用户需要与其它VLAN的用户进行通信时，该用户只需将数据包发送给缺省网关，缺省网关修改数据帧的VLAN标签后再发送至目的主机所在VLAN，即完成了VLAN间的通信。 

第三种解决办法就是三层交换机，它是将路由器和交换机合成的一种设备，融合了路由器和交换机各自的优势 

基于端口的VLAN
这种划分VLAN的方法是根据以太网交换机的端口来划分，比如交换机的1~4端口为VLAN A，5~17为VLAN B，18~24为VLAN C。当然，这些属于同一VLAN的端口可以不连续，如何配置，由管理员决定。
图中端口1和端口2被指定属于VLAN 1，端口3和端口4被指定属于VLAN 2。
如果有多个交换机的话，例如，可以指定交换机 1 的1~6端口和交换机 2 的1~4端口为同一VLAN，即同一VLAN可以跨越数个以太网交换机，根据端口划分是目前定义VLAN的最常用的方法。这种划分的方法的优点是定义VLAN成员时非常简单，只要将所有的端口都指定一下就可以了。它的缺点是如果VLAN A的用户离开了原来的端口，到了一个新的交换机的某个端口，那么就必须重新定义。 

基于MAC地址的VLAN
交换机维护一张VLAN映射表，这个VLAN表记录MAC地址和VLAN的对应关系


基于IP子网的VLAN
根据报文中的IP地址决定报文属于哪个VLAN：同一个IP子网的所有报文属于同一个VLAN。这样，可以将同一个IP子网中的用户被划分在一个VLAN内。

基于用户的VLAN

基于网络协议的VLAN


路由器有两大典型功能，即数据通道功能和控制功能。
数据通道功能包括转发决定、背板转发以及输出链路调度等，一般由特定的硬件来完成;
控制功能一般用软件来实现，包括与相邻路由器之间的信息交换、系统配置、系统管理等。

在路由器技术的发展历程中，性能和业务这两个因素发挥着关键作用。
一方面，带宽和网络规模的增长推动着路由器在性能、容量方面断提升；
另一方面，业务的发展驱动着路由器更加智能化和具备更强的业务提供能力。

第一代路由器：集中转发，总线交换
最初的IP网络并不大，其网关所需要连接的设备及其需要处理的负载也很小。这个时候网关(路由器)基本上可以用一台计算机插多块网络接口卡的方式来实现。接口卡与中央处理器(CPU)之间通过内部总线相连，CPU负责所有事务处理，包括路由收集、转发处理、设备管理等。网络接口收到报文后通过内部总线传递给CPU，由CPU完成所有处理后从另一个网络接口传递出去。
cpu + 内部总线 + 多个网卡
cpu + 内部总线处理一切业务，cpu是瓶颈

第二代路由器：集中+分布转发，接口模块化，总线交换等技术
由于每个报文都要经过总线送交CPU处理，随着网络用户的增多，网络流量不断增大，接口数量、总线带宽和CPU的瓶颈效应越来越突出。于是很自然地想到：如何提高网络接口数量，如何降低CPU、总线的负担？为了解决这个问题，第二代路由器就在网络接口卡上进行一些智能化处理，由于网络用户通常只会访问少数的几个地方，因此可以考虑把少数常用的路由信息采用Cache技术保留在业务接口卡上，这样大多数报文就可以直接通过业务板Cache的路由表进行转发，以减少对总线和CPU的需求。
网卡+cache分担cpu的业务

第三代路由器：分布转发，总线交换
上世纪90年代出现的Web技术使IP网络得到了迅猛发展，用户的访问面获得了极大的拓宽，访问的地方也不再像过去那样固定，于是经常出现无法从Cache找到路由的现象，总线、CPU的瓶颈效应再次出现。另外，由于用户的增加和路由器接口数量不足引发的问题也再次暴露出来了。为了解决这些问题，第三代路由器应运而生。第三代路由器采用全分布式结构—路由与转发分离的技术，主控板负责整个设备的管理和路由的收集、计算功能，并把计算形成的转发表下发到各业务板;各业务板根据保存的路由转发表能够独立进行路由转发。另外总线技术也得到了较大的发展，通过总线、业务板之间的数据转发完全独立于主控板，实现了并行高速处理，使得路由器的处理性能成倍提高。
cpu只负责收集路由，产生路由，生成fib表，下发给业务板
业务板负责转发，业务板上也有cpu
总线布局进一步改进

第四代路由器：ASIC分布转发，网络交换
九十年代中后期，随着IP网络的商业化，Web技术出现以后，Internet技术得到空前的发展，Internet用户迅猛增加。网络流量特别是核心网络的流量以指数级增长，传统的基于软件的IP路由器已经无法满足网络发展的需要。以常见的主干节点2.5G POS端口为例，按照IP最小报文40字节计算，2.5G POS端口线速的流量约为6.5Mpps。而且报文处理中需要包含诸如QoS保证、路由查找、二层帧头的剥离/添加等复杂操作，以传统的做法是不可能实现的。于是一些厂商提出了ASIC实现方式，它把转发过程的所有细节全部采用硬件方式来实现。另外在交换网上采用了Crossbar或共享内存的方式解决了内部交换的问题。这样，路由器的性能达到千兆比特，即早期的千兆交换式路由器(Gigabit Switch Router，GSR)。
业务板的业务，软件实现太慢，全部硬件实现
总线引入了交换网技术；交换网的引入解决了总线的瓶颈，实现无阻塞交换。


专用集成电路ASIC是指应特定需要而设计制造的集成电路，在网络芯片中使用广泛。它通过把指令或计算逻辑固化到芯片中，获得很高的处理能力，实现性能极高的网络功能。一般来说，ASIC针对特定功能，采用的是相对封闭而集中的软硬件开发平台，如果要引入新的网络协议和功能，必须重新设计ASIC，这一点无疑让设备商非常头疼。现在，可编程的ASIC技术已经出现，它将一些对性能要求高、重要的网络功能模块或者需要升级的功能置于可编程的电路层，大大增加网络的灵活性，同时保护用户投资。

但遗憾的是，目前仅少部分网络设备供应商能支持ASIC。因为开发定制芯片需要巨大的成本投入，同时需要最短2年的研发时间。绝大部分的网络设备商依靠专业芯片制造商如博通，Intel旗下Fulcrum，Marvell等生产的通用网络芯片，只有Juniper和思科这样的巨头更倾向于采用ASIC芯片，可提供比采用纯软件更快的网络性能。

第五代路由器技术：网络处理器分布转发，网络交换
在第四代路由器中采用了硬件转发模式，解决了带宽容量和性能不足的瓶颈问题，但是也留下了隐患：基于ASIC的硬件转发在获取高性能的同时，牺牲了业务灵活性。这与ASIC技术实现方式相关，在设计ASIC芯片的时候，对转发流程做了大量优化，使得IP转发以简单而固定的方式来实现，从而固化下来，做到硬件化。如果在IP转发中，还要做一些复杂的额外处理的话，ASIC就无能为力了。而且，ASIC的设计周期很长，通常需要二到三年才能设计出一个稳定运行的ASIC芯片。而在IP互联网领域，业务发展非常迅速，平均每半年就会兴起一项新的业务，而这些业务可能就对转发流程有影响，需要转发程序适度调整来获得高品质支持。近期MPLS VPN技术逐步成为热门，运营商需要在骨干网、城域网中开展MPLS VPN业务，这时发现原来在骨干网应用的第四代路由器无法提供高性能的VPN业务，需要全面升级或另外建设专门的VPN承载网络。在当前带宽已经不是主要矛盾，业务应用为王的运营环境中，ASIC固有的灵活性差、业务支持不足的问题成为了路由器发展的主要矛盾。新的需要，带来新的矛盾，就又会造就新的发展。网络处理器技术兴起，促使第五代路由器出现。
网络处理器（Network Processor，简称NP），根据国际网络处理器会议（Network Processors Conference）的定义：网络处理器是一种可编程器件，它特定的应用于通信领域的各种任务，比如包处理、协议分析、路由查找、声音/数据的汇聚、防火墙、QoS等。网络处理器器件内部通常由若干个微码处理器和若干硬件协处理器组成，多个微码处理器在网络处理器内部并行处理，通过预先编制的微码来控制处理流程。而对于一些复杂的标准操作(如内存操作、路由表查找算法、QoS的拥塞控制算法、流量调度算法等)则采用硬件协处理器来进一步提高处理性能，从而实现了业务灵活性和高性能的有机结合。
硬件可编程


1：cpu+网卡==业务+性能
2：cache分担			-- 软件
3：路由生成/转发分离	-- 软件
4: 硬件实现转发，硬件不可编程   -- 硬件
5: 硬件实现转发，硬件可编程     -- 硬件


MPLS L2VPN提供基于MPLS网络的二层VPN服务。
使用基于MPLS的L2VPN解决方案，运营商可以在统一的MPLS网络上提供不同基于媒介的二层VPN服务，包括ATM、FR、VLAN、Ethernet、PPP等。同时，这个MPLS网络仍然可以提供通常的IP、三层VPN、流量工程和QOS等其他服务，极大地节省网络建设的投资。
简单来说，MPLS L2VPN就是在MPLS网络上透明传递用户的二层数据。
从用户的角度来看，这个MPLS网络就是一个二层的交换网络，通过这个网络，可以在不同站点之间建立二层的连接。以ATM为例，每一个用户边缘设备（CE）配置一个ATM虚电路，通过MPLS网络与远端的另一个CE设备相连，与通过ATM网络实现互联是完全一样的。
在传统的没有MPLS的ATM或FR网络中， 二层VPN由虚电路（VC）提供。
对于每一条VC，网络中的边缘设备（PE）和核心设备（P）都需要维护完整的VC信息。这样，当运营商要连接PE上的多个CE设备时，需要建立多条VC，因此，在PE和P设备上需要维护许多VC的信息。
而对于MPLS L2VPN，通过使用标签栈技术，可以在一条LSP中复用多条VC，因此PE只要维护一条LSP信息就可以了，因此大大提高了系统的可扩展性。
它也是利用标记栈来实现用户报文在MPLS网络中的透明传送：外层标记（称为tunnel标记）用于将报文从一个PE传递到另一个PE，内层标记（在MPLS L2VPN中，称为VC标记）用于区分不同的VPN中的不同连接，接收方的PE根据VC标记决定将报文传递给哪个CE。
Martini草案定义了通过建立点到点的链路来实现L2VPN的方法。它以LDP为信令协议来传递双方的VC标记。由于在运营商网络中，只有PE设备需要保存少量的VC label&LSP的映射等少量信息，P设备不包含任何二层VPN信息，所以扩展性很好。此外，当需要新增加一条VC时， 只在相关的两端PE设备上各配置一个单方向VC连接即可，不影响网络的运行。
与Kompella方式相比，由于它不依赖于定时刷新机制， 所以对故障的感知速度要快。
Martini方式适合稀疏的二层连接，例如星型连接。

GRE（Generic Routing Encapsulation）是一种3层VPN技术，两个具有IP可达性的场点间的GRE隧道可被称为VPN，因为场点间的私有数据被封装在GRE递送包头中。
GRE隧道可以用来连接企业的私有网点，但由于GRE本身缺乏足够强大的安全机制，所以很少被用来单独传输数据。
GRE通常和IPSec联合使用。IPSec是一种点对点的隧道协议，无法支持对多播报文的封装，而GRE可以，所以我们通常用GRE over IPSec，即先用GRE封装多播报文，再用IPSec封装GRE报文的方式来进行多播数据的加密传输。

Tunnel是一个虚拟的点对点的连接，在实际中可以看成仅支持点对点连接的虚拟接口，这个接口提供了一条通路使封装的数据报能够在这个通路上传输，并且在一个Tunnel的两端分别对数据报进行封装及解封 。


实现VPN的关键技术有：
隧道化协议（Tunneling Protocol）
          隧道技术是将分组封装（Capsule）的技术，它是VPN实现以内部网地址通信与多协议通信的重要功能，PPTP、L2TP、IPSec、GRE和GTP被广泛采用。
认证协议
          在远程访问VPN中，使用了用户名及口令，它们被用来判断用户名是否有权访问。PPP采用了PAP（Password Authentication Protocol）及CHAP（Challenge Handshake Authentication Protocol）等规程进行认证。PPTP及L2TP等隧道协议采用这种PPP的认证协议。
加密技术
          加密技术由IPSec ESP（Encapsulating Secutity Payload）。

netfilter/iptables IP 信息包过滤系统被称为单个实体，但它实际上由两个组件netfilter 和 iptables 组成。
netfilter 组件也称为内核空间（kernelspace），是内核的一部分，由一些信息包过滤表组成，这些表包含内核用来控制信息包过滤处理的规则集。
iptables 组件是一种工具，也称为用户空间（userspace），它使插入、修改和除去信息包过滤表中的规则变得容易。

作者一共在内核空间中选择了5个位置，
    1.内核空间中：从一个网络接口进来，到另一个网络接口去的 -- 3.FORWARD (转发管卡)
    2.数据包从内核流入用户空间的 -- 2.INPUT (数据包流入口)
    3.数据包从用户空间流出的 -- 4.OUTPUT(数据包出口)
    4.进入/离开本机的外网接口 -- 尚未决定路由 -- PREROUTING (路由前)
    5.进入/离开本机的内网接口 -- 尚未决定路由-- POSTROUTING（路由后）
这五个位置也被称为五个钩子函数（hook functions）,也叫五个规则链。
		1.PREROUTING (路由前)
		2.INPUT (数据包流入口)
		3.FORWARD (转发管卡)
		4.OUTPUT(数据包出口)
		5.POSTROUTING（路由后）

由于数据包尚未进行路由决策，还不知道数据要走向哪里，所以在进出口是没办法实现数据过滤的。所以要在内核空间里设置转发的关卡，进入用户空间的关卡，从用户空间出去的关卡。那么，既然他们没什么用，那我们为什么还要放置他们呢？因为我们在做NAT和DNAT的时候，目标地址转换必须在路由之前转换。所以我们必须在外网而后内网的接口处进行设置关卡。        		
		
1.1 filter、nat、mangle等规则表

filter表

主要用于对数据包进行过滤，根据具体的规则决定是否放行该数据包（如DROP、ACCEPT、REJECT、LOG）。filter 表对应的内核模块为iptable_filter，包含三个规则链：

INPUT链：INPUT针对那些目的地是本地的包
FORWARD链：FORWARD过滤所有不是本地产生的并且目的地不是本地(即本机只是负责转发)的包
OUTPUT链：OUTPUT是用来过滤所有本地生成的包
nat表

主要用于修改数据包的IP地址、端口号等信息（网络地址转换，如SNAT、DNAT、MASQUERADE、REDIRECT）。属于一个流的包(因为包
的大小限制导致数据可能会被分成多个数据包)只会经过这个表一次。如果第一个包被允许做NAT或Masqueraded，那么余下的包都会自动地被做相同的操作，也就是说，余下的包不会再通过这个表。表对应的内核模块为 iptable_nat，包含三个链：

PREROUTING链：作用是在包刚刚到达防火墙时改变它的目的地址
OUTPUT链：改变本地产生的包的目的地址
POSTROUTING链：在包就要离开防火墙之前改变其源地址
mangle表

主要用于修改数据包的TOS（Type Of Service，服务类型）、TTL（Time To Live，生存周期）指以及为数据包设置Mark标记，以实现Qos(Quality Of Service，服务质量)调整以及策略路由等应用，由于需要相应的路由设备支持，因此应用并不广泛。包含五个规则链——PREROUTING，POSTROUTING，INPUT，OUTPUT，FORWARD。

raw表

是自1.2.9以后版本的iptables新增的表，主要用于决定数据包是否被状态跟踪机制处理。在匹配数据包时，raw表的规则要优先于其他表。包含两条规则链——OUTPUT、PREROUTING

iptables中数据包和4种被跟踪连接的4种不同状态：

NEW：该包想要开始一个连接（重新连接或将连接重定向）
RELATED：该包是属于某个已经建立的连接所建立的新连接。例如：FTP的数据传输连接就是控制连接所 RELATED出来的连接。--icmp-type 0 ( ping 应答) 就是--icmp-type 8 (ping 请求)所RELATED出来的。
ESTABLISHED ：只要发送并接到应答，一个数据连接从NEW变为ESTABLISHED,而且该状态会继续匹配这个连接的后续数据包。
INVALID：数据包不能被识别属于哪个连接或没有任何状态比如内存溢出，收到不知属于哪个连接的ICMP错误信息，一般应该DROP这个状态的任何数据。
1.2 INPUT、FORWARD等规则链和规则

在处理各种数据包时，根据防火墙规则的不同介入时机，iptables供涉及5种默认规则链，从应用时间点的角度理解这些链：

INPUT链：当接收到防火墙本机地址的数据包（入站）时，应用此链中的规则。
OUTPUT链：当防火墙本机向外发送数据包（出站）时，应用此链中的规则。
FORWARD链：当接收到需要通过防火墙发送给其他地址的数据包（转发）时，应用此链中的规则。
PREROUTING链：在对数据包作路由选择之前，应用此链中的规则，如DNAT。
POSTROUTING链：在对数据包作路由选择之后，应用此链中的规则，如SNAT。
防火墙处理数据包的方式（规则）：

ACCEPT：允许数据包通过
DROP：直接丢弃数据包，不给任何回应信息
REJECT：拒绝数据包通过，必要时会给数据发送端一个响应的信息。
SNAT：源地址转换。在进入路由层面的route之前，重新改写源地址，目标地址不变，并在本机建立NAT表项，当数据返回时，根据NAT表将目的地址数据改写为数据发送出去时候的源地址，并发送给主机。解决内网用户用同一个公网地址上网的问题。
MASQUERADE，是SNAT的一种特殊形式，适用于像adsl这种临时会变的ip上
DNAT:目标地址转换。和SNAT相反，IP包经过route之后、出本地的网络栈之前，重新修改目标地址，源地址不变，在本机建立NAT表项，当数据返回时，根据NAT表将源地址修改为数据发送过来时的目标地址，并发给远程主机。可以隐藏后端服务器的真实地址。
REDIRECT：是DNAT的一种特殊形式，将网络包转发到本地host上（不管IP头部指定的目标地址是啥），方便在本机做端口转发。
LOG：在/var/log/messages文件中记录日志信息，然后将数据包传递给下一条规则
除去最后一个LOG，前3条规则匹配数据包后，该数据包不会再往下继续匹配了，所以编写的规则顺序极其关键。



	
