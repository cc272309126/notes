关系
作为一个传输层协议，SCTP兼有TCP及UDP两者的特点。SCTP可以称为是TCP的改进协议，但它们之间仍然存在着较大的差别。
l 首先SCTP和TCP之间的最大区别是SCTP的连接可以是多宿主连接的，TCP则一般是单地址连接的。在进行SCTP建立连接时，双方均可声明若干IP地址（IPv4，IPv6或主机名）通知对方本端所有的地址。若当前连接失效，则可切换到另一个地址，而不需要重新建立连接。
l 其次SCTP是基于消息流，而TCP则是基于字节流。所谓基于消息流，是指发送数据和应答数据的最小单位是消息包（chunk）。一个SCTP连接（Association）同时可以支持多个流（stream），每个流包含一系列用户所需的消息数据（chunk）。而TCP则只能支持一个流。
l 在网络安全方面，SCTP增加了防止恶意攻击的措施。不同于TCP连接采用的三次握手机制，SCTP连接采用四次握手机制，有效的防止了类似于SYN Flooding的防范拒绝服务攻击。SCTP主要的贡献是对多重联外线路的支持，一个端点可以由多于一个IP地址组成，使得传输可在主机间或网卡间做到透明的网络容错备援。
SCTP包结构
一个数据SCTP包首部可跟一个或多个可变长的块。块采用TLV（Type/Length/Value，类型/长度/值）的格式。
源端口、目的端口、校验码的意义同TCP中的意义相似。确认标签保存着在SCTP握手中第一次交换的初始标签的值。在关联中，任何SCTP数据包若不包含这样一个标签，当到达时会被接收端丢弃。
在每个块中，TLV包括块类型、传输处理标记、块长度。不同的块类型可用来传输控制信息或数据。
TSN（Transmission Sequence Number，传输顺序号）和SSN（Stream Sequence Number，流顺序号）是两种不同的序列号，TSN保证整个关联的可靠性，而SSN保证整个流的有序性，这样，在传输中，将数据的可靠性与有序性独立分开。
SCTP数据交换
在两个SCTP主机间的正常数据交换。SCTP主机发送SACK（Selective Acknowledgement，选择性确认）块，用来确认每一个收到的SCTP包。因为SACK能完整地描述接收端的状态，因此，依据SACK，发送端能做出重传判决。SCTP支持类似于TCP中的快速重传和time-out重传算法。
对于数据包丢失发现，SCTP和TCP采用截然不同的机制：当TCP发现接收序号有缺口时，会等到该缺口被填上后，才发送序列号高于丢失数据包的数据。然而，SCTP即使发现接收序号有缺口或顺序错乱，仍会发送后面的数据。
SCTP关闭关联
作为面向连接的传输协议，SCTP也运用三路握手来关闭一个关联，但与TCP有一点不同：一个TCP终端在“关联关闭”的过程中能够保持连接开启，并从对端接收新的数据，而SCTP不支持TCP的这种“半关闭”状态。
1．主机A发出“关闭”（SHUTDOWN）块来终止与主机B的关联，主机A进入“SHUTDOWN-PENDING”状态，对应的动作是：不再接受上层应用的数据，只发送队列中剩余的数据，进入“SHUTDOWN-SENT”状态。
2．主机B一旦接收到“关闭”块，就进入“SHUTDOWN-RECEIVED”状态，同主机A一样，不再接受上层应用的数据，只发送队列中剩余的数据。
3．主机A再次发送“关闭”块，通知主机B所发送的剩余数据已到达，并且重申了关联正在关闭。
4．当第二次收到“关闭”块时，主机B发送“确认关闭”块。
5．主机A随后发送“关闭结束”块，完成本次关联的关闭。
特性
多宿主
多宿主为应用程序提供了比TCP更高的可用性。多宿主主机就是一台具有多个网络接口的主机，因此可以通过多个IP地址来访问这台主机。在TCP中，连接（connection）是指两个端点之间的一个通道（在这种情况下，就是两台主机的网络接口之间的一个套接字）。SCTP引入了联合（association）的概念，它也是存在于两台主机之间，但可以使用每台主机上的多个接口进行协作。图2阐述了TCP连接与SCTP联合之间的区别。
 
图2TCP连接与SCTP联合
该图的上面部分是TCP连接，每个主机都只包含一个网络接口；连接是在每个客户机和服务器之间的单个接口之间建立的。在建立连接时，就被绑定到了每个接口上。在该图的下面部分中，您可以看到这样一个架构：每台主机上都包含两个网络接口。通过独立网络提供了两条路径，一条是从接口C0到S0，另外一条是从接口C1到S1。在SCTP中，这两条路径可以合并到一个联合中。
SCTP负责使用内嵌的heartbeat机制来监视联合的路径；在检测到一条路径失效时，协议就会通过另外一条路径来发送通信数据。应用程序甚至都不必知道发生了故障恢复。故障转移也可以用于维护网络应用程序的连通性。例如，让我们来考虑一台包含一个无线802.11接口和一个以太网接口的笔记本的例子。当笔记本放到固定的位置上时，我们倾向于使用高速的以太网接口（在SCTP中称为主地址（primaryaddress））；但是在这个连接丢失时（例如离开了固定位置），连接可迁移到无线接口上。在返回固定位置时，以太网连接会被重新检测到，通信就可以在这个接口上恢复。这是一种能提供更高的可用性和可靠性的强大机制。
多流
从某种意义上来讲，SCTP连接与TCP连接类似，不同之处只是SCTP能够在一个联合中支持多流机制。一个联合中的所有流都是独立的，但均与该联合相关（参见图3）。
 
图3.SCTP联合与流之间的关系
每个流都给定了一个流编号，它被编码到SCTP报文中，通过联合在网络上传送。多流非常重要，因为阻塞的流（例如等待重传的流会导致报文的丢失）不会影响同一联合中的其他流。这个问题统称为head-of-lineblocking（对头阻塞）。TCP很容易出现这类阻塞问题。
多流如何在传输数据时提供更好的响应性呢？例如，HTTP协议会在相同套接字上共享控制和数据。Web客户机从服务器上请求一个文件，服务器通过相同的连接将这个文件发回给客户机。多流的HTTP服务器可以提供更好的交互能力，因为在联合中各单独的流上可以处理多个请求。这种功能可以并行化响应，尽管速度不一定会更快，但可以同时加载HTML和图像映像，从而表现出更好的响应性。
多流处理是SCTP的一个重要特性，尤其是在协议的设计中考虑一些控制和数据的问题时更是如此。在TCP中，控制和数据通常都是通过相同的连接进行共享的，这可能会产生问题，因为控制报文可能会在数据报之后延时。如果控制和数据被划分成单独的流，控制数据就可以以一种更及时的方式进行处理，从而可以更好地利用可用资源。
初始化保护
TCP和SCTP中对新连接的初始化是通过报文握手来完成的。在TCP中，这种机制称为三次握手（three-wayhandshake）。客户机向服务器首先发送一个SYN报文（Synchronize的简写），服务器使用一个SYN-ACK报文进行响应（Synchronize-Acknowledge）。最后，客户机使用一个ACK报文确认已接收到报文（请参见图4）。
 
图4.TCP和STCP握手使用的报文交换
当恶意客户机使用虚假的源地址来伪造一个IP报文时，TCP就会出现问题了，这会大量TCPSYN报文攻击服务器。服务器在接收SYN报文之前，要为连接分配资源，但是在大量产生SYN报文的情况下，最终会耗尽自己的资源，从而无法处理新的请求。这种情况就称为服务拒绝（DenialofService）（DoS）攻击。
SCTP可以通过一种4次握手的机制并引入cookie的概念来有效地防止这种攻击的产生。在SCTP中，客户机使用一个INIT报文发起一个连接。服务器使用一个INIT-ACK报文进行响应，其中就包括了cookie（标识这个连接的惟一上下文）。客户机然后就使用一个COOKIE-ECHO报文进行响应，其中包含了服务器所发送的cookie。服务器要为这个连接分配资源，并通过向客户机发送一个COOKIE-ACK报文对其进行响应。
要解决使用这种4次握手机制解决延时数据移动的问题，SCTP允许把数据包含到COOKIE-ECHO和COOKIE-ACK报文中。
消息分帧
使用消息分帧机制，就可以保护消息只在一个边界内通过socket进行通信；这意味着如果客户机向服务器先发送100个字节，然后又发送50个字节。那么服务器就会在两次读取操作中分别读取到100个字节和50个字节。UDP也是这样进行操作，这对于面向消息的协议非常有益。
与此不同，TCP是按照字节流的方式进行操作。如果没有分帧机制，一端接收到的数据可能比另外一端发送的数据多或少（这会将一次写操作划分成多次操作，或者将多次写操作合并到一个读操作中）。这种行为需要在TCP之上进行操作的面向消息的协议可以在应用层中提供数据缓冲和消息分帧机制（这可能是一项复杂的任务）。
SCTP在数据传输中提供了消息分帧功能。当一端对一个套接字执行写操作时，可确保对等端读出的数据大小与此相同（请参见图5）。对于面向流的数据来说，例如音频和视频数据，可以没有分帧机制。
 
图5.UDP/SCTP中的消息分帧与面向字节流协议的比较
可配置的无序发送
SCTP中的消息的传输十分可靠，但未必是按照想要的次序来传输的。TCP可以确保数据是按照次序发送的（考虑到TCP是一种流协议，这是一件好事）。UDP无法确保有序地发送数据。但是如果需要，您也可以在SCTP中配置流来接受无序的消息。这种特性在面向消息的协议中可能非常有用，因为其中的消息都是独立的，次序并不重要。另外，您可以在一个联合中按照逐个流配置无序发送。
平滑关闭
TCP和SCTP都是基于连接的协议，而UDP则是一种无连接的协议。TCP和SCTP都需要在对等的两端建立和拆除连接。SCTP与TCP中关闭连接的不同之处在于TCP中连接的删除是半关闭（half-close）的。图6给出了TCP和SCTP的关闭序列。
 
图6TCP和SCTP的连接结束序列
TCP中，一端可以关闭自己这端的socket（这样会导致发送一个FIN报文），但是仍然可以继续接收数据。FIN说明这个端点不会再发送数据，但是在这一端关闭自己这端的套接字之前，它一直可以继续传输数据。应用程序很少使用这种半关闭状态，因此SCTP的设计者就选择放弃这种状态，并将其替换成了一个显式的终结序列。当一端关闭自己的套接字时（导致产生一个SHUTDOWN原语），对等的两端全部需要关闭，将来任何一端都不允许再进行数据的移动了。
SCTP四路握手及抵抗SYN Flooding攻击的原理
一个SCTP关联定义为：[主机A的一组IP地址]+[主机A的端口]+ [主机B的一组IP地址]+[主机B的端口]。因此，每一端对应组中的任何一个IP地址都可作为相应的源/目的地址来标示本次关联，通过四路握手，两端SCTP主机交换通信状态。
SYN Flooding利用了TCP/IP的固有漏洞，面向连接的TCP三次握手是SYN Flooding存在的基础。
SYN Flooding攻击的原理是：恶意的攻击者大量向服务器发送SYN报文，服务器在发出SYN+ACK应答报文后无法收到客户端的ACK报文（第三次握手无法完成），服务器端将为维护一个非常大的半连接列表而消耗非常多的CPU时间和内存资源，还要不断对这个列表中的IP进行SYN+ACK的重试。服务器端将忙于处理攻击者伪造的TCP连接请求而无暇理睬客户的正常请求，此时从正常客户的角度看来，服务器失去响应。
而在一次SCTP四路握手中，INIT（Initiation，开始）消息的接收端不必保存任何状态信息或者分配任何资源，这样就可防范SYN Flooding等DoS攻击。它在发送INIT-ACK消息时，采用了一种机制“状态Cookie”，该Cookie具有发送端要建立自己状态所需的全部信息。
SCTP产生一个状态Cookie的过程如下：
1．使用收到的INIT和发出的INIT-ACK块中的信息创建一个关联的TCB（Transmission Control Block，传输控制块）。
2．在TCB中，将当前日期设为创建日期，将协议参数“有效Cookie时间”设为生存期间。
3．根据TCB，收集重建TCB所需的最小信息子集，将该子集和密钥产生一个MAC（Message Authentication Code，消息验证码）。
4．结合上述最小信息子集和MAC产生状态Cookie。
5．在发送完INIT ACK（包含状态Cookie参数）后，发送方必须删除TCB以及任何与新关联有关的本地资源。
INIT和INIT-ACK都必须包含建立初始状态所需的参数：一组IP地址，保证可靠传输的初始TSN，每个被接收的SCTP包中必须含有的初始标签，每一端请求发出的流数目和每一端能支持接收的流数目。
交换完这些消息之后，INIT的发送端以COOKIE-ECHO消息的方式发送回状态Cookie。接收端根据所接收到的COOKIE-ECHO中的状态Cookie，完整地重建自己的状态，并回送COOKIE-ACK来确认关联已建立。COOKIE-ECHO和COOKIE-ACK都可将用户数据消息绑定到各自的包中。
由此可见，采用以上这种方式，即使接收再多的INIT消息，接收端也没有任何资源的消耗：它既不分配任何系统资源，也不保存此次新关联的状态，它只是把相应重建状态所用的状态Cookie作为参数，包含在每一个回送的INIT-ACK消息中，最后该状态Cookie会被COOKIE-ECHO消息发送回来。
SCTP的未来发展
SCTP是一个相当新的协议，它在2000年10月份才成为一个RFC规范。从那以后，它开始进入所有的主流操作系统，包括GNU/Linux、BSD和Solaris。在Microsoft Windows操作系统上也有第三方的商业包可以使用。
在获得高可用性的同时，应用程序也已经开始使用SCTP作为自己的主要传输机制。诸如FTP（File Transfer Protocol，文件传输协议）和HTTP（Hypertext Transfer Protocol，超文本传输协议）之类的传统应用程序已经在SCTP的特性基础上进行了构建。其他一些协议也正在开始使用SCTP，例如SIP（Session Initiation Protocol，会话初始化协议）和SS7（Signaling System No.7，七号信令系统）。在商业领域中，您可以在Cisco的IOS（Inter-Operation Specification，互操作规范）中找到SCTP的影子。
随着SCTP 被吸纳到2.6版本的Linux内核中，我们可以构建并部署高可用性、高可靠性的网络应用程序。作为一种基于IP的协议，SCTP不但可以无缝地替换TCP和UDP，而且扩展了很多新服务，例如多宿主、多流，并且对安全性也有了很大的提高。[2] 


浅析——SCTP协议
Posted on 2011-07-13 21:26 李大嘴 阅读(6547) 评论(0) 编辑 收藏
SCTP处于SCTP用户应用层与IP网络层之间，它运用“关联”（association）这个术语定义交换信息的两个对等SCTP用户间的协议状态 。SCTP也是面向连接的，但在概念上，SCTP“关联”比TCP连接更为广泛：TCP的连接只有一个源地址和一个目的地址，SCTP提供一种方式使得每 个SCTP端点能为另一个对等端点提供一组传输地址，即传输地址= 一组IP地址+端口号。 

在继承TCP特点的基础上，SCTP提供了一些额外的功能： 

1. 在多个“流”（stream）中实现用户数据的有序发送 

“流” 在TCP中指一系列的字节，而在SCTP中是指发送到上层协议的一定系列的用户消息，这些消息的顺序与流内其他消息相关。SCTP用户在建立关联时，可以 规定关联支持的流的数目。这个数目是与源端商定的，用户消息与流数目关联。在链路中，SCTP为每个送到对等端的消息分配一个流序号。在接收端，SCTP 确保在给定流中消息按顺序发送。同时，当一个流正在等待下一个非顺序的用户消息时，其他流的发送会继续。 

2. 根据已发现的路径MTU（最大传输单元）大小进行用户数据分片 

为了确保发送到下层的SCTP数据包与路径MTU一致，SCTP对用户消息分片。在接收端，分片被重组后传给上层SCTP用户。 

3. 选择性确认（SACK）和拥塞控制 

选择性确认用于数据包丢失发现，TCP中确认序号返回的是发送方已成功收到数据字节序号（不包含确认序号所指的字节），而SCTP反馈给发送端的是丢失的并且要求重传的消息序号。 

SCTP运用了TCP中的拥塞控制技术，包括慢启动，拥塞避免和快速重传。因此，当和TCP应用共存时，SCTP应用可接收属于SCTP的网络资源部分。 

4. 块（chunk）绑定 

即多个用户消息可选择地绑定到一个SCTP包上，通过将消息放到一个或多个SCTP数据结构——“块”中，SCTP保留了应用程序的消息框架边界。不同类型的块可绑定到一个SCTP包中，但是控制块必须放在任何一个数据块之前。 

5. 路径管理 

SCTP 路径管理功能主要负责从远端提供的一组传输地址中选择目的传输地址，它根据两个方面来选择目的地址：SCTP用户指示和当前可达的合格目的地。当其他流控 制不能提供可达性信息时，路径管理功能定时地扫描链路的可达性，并向SCTP报告远端传输地址所发生的变化。SCTP 路径管理功能模块同时还负责在建立链路时，向远端报告可用的本地地址，并把远端返回的传输地址告诉SCTP用户。 

6. 支持多宿 

当SCTP传送数据包给目的IP地址时，如果此IP地址是不可达的，SCTP可以将消息重路由给一个交替的IP地址。这样，在关联的一端甚至两端，可容忍网络级错误。 

7. 防范拒绝服务（DoS）攻击 

DoS 的攻击方式有很多种，最基本的DoS攻击就是利用合理的服务请求来占用过多的服务资源，从而使合法用户无法得到服务的响应。SYN Flooding攻击是DoS攻击的一种实例，是目前效果最好的一种黑客攻击方式。为了抵抗SYN Flooding对目标主机攻击，SCTP在关联初始化阶段实施了一种安全的“Cookie”机制。 

8. 支持多种传输模式 

严格有序传输（像TCP），部分有序传输（像per-stream）和无序传输（像UDP）。 
2 SCTP包结构 

SCTP 包的结构，一个数据包首部可跟一个或多个可变长的块。块采用“类型—长度—值”（TLV）的格式。源端口、目的端口、校验码的意义同TCP中的意义相似。 确认标签保存着在SCTP握手中第一次交换的初始标签的值。在关联中，任何SCTP数据包若不包含这样一个标签，当到达时会被接收端丢弃。 

在每个块中，TLV包括块类型、传输处理标记、块长度。不同的块类型可用来传输控制信息或数据。 

传输序列号（TSN）和流序列号（SSN）是两种不同的序列号，TSN保证整个关联的可靠性，而SSN保证整个流的有序性，这样，在传输中，将数据的可靠性与有序性独立分开。 
3 SCTP数据传输 

4.1 SCTP四路握手及抵抗SYN Flooding攻击的原理 

一个SCTP关联定义为：[主机A的一组IP地址]+[主机A的端口]+ [主机B的一组IP地址]+[主机B的端口]。 因此，每一端对应组中的任何一个IP地址都可作为相应的源/目的地址来标示本次关联，通过四路握手，两端SCTP主机交换通信状态。 

SYN Flooding利用了TCP/IP的固有漏洞，面向连接的TCP三次握手是SYN Flooding存在的基础。SYN Flooding攻击的原理是：恶意的攻击者大量向服务器发送SYN报文，服务器在发出SYN+ACK应答报文后无法收到客户端的ACK报文（第三次握手 无法完成），服务器端将为维护一个非常大的半连接列表而消耗非常多的CPU时间和内存资源，还要不断对这个列表中的IP进行SYN+ACK的重试。服务器 端将忙于处理攻击者伪造的TCP连接请求而无暇理睬客户的正常请求，此时从正常客户的角度看来，服务器失去响应。 

而在一次SCTP四路 握手中，INIT消息的接收端不必保存任何状态信息或者分配任何资源，这样就可防范SYN Flooding等DoS攻击。它在发送INIT-ACK消息时，采用了一种机制——“状态Cookie”，该Cookie具有发送端要建立自己状态所需 的全部信息。 

SCTP产生一个状态Cookie的过程如下： 

1. 使用收到的INIT和发出的INIT- ACK块中的信息创建一个关联的TCB（传输控制块）。 

2. 在TCB中，将当前日期设为创建日期，将协议参数“有效Cookie时间”设为生存期间。 

3. 根据TCB，收集重建TCB所需的最小信息子集，将该子集和密钥产生一个MAC（信息认证编码）。 

4. 结合上述最小信息子集和MAC产生状态Cookie。 

5. 在发送完INIT ACK（包含状态Cookie参数）后，发送方必须删除TCB以及任何与新关联有关的本地资源。 

INIT 和INIT-ACK都必须包含建立初始状态所需的参数：一组IP地址，保证可靠传输的初始TSN，每个被接收的SCTP包中必须含有的初始标签，每一端请 求发出的流数目和每一端能支持接收的流数目。交换完这些消息之后，INIT的发送端以COOKIE-ECHO消息的方式发送回状态Cookie。接收端根 据所接收到的COOKIE-ECHO中的状态Cookie，完整地重建自己的状态，并回送COOKIE- ACK来确认关联已建立。COOKIE-ECHO和COOKIE-ACK都可将用户数据消息绑定到各自的包中。 

由此可见，采用以上这种 方式，即使接收再多的INIT消息, 接收端也没有任何资源的消耗：它既不分配任何系统资源，也不保存此次新关联的状态，它只是把相应重建状态所用的状态Cookie作为参数，包含在每一个回 送的INIT-ACK消息中，最后该状态Cookie会被COOKIE-ECHO消息发送回来。 

2.2 SCTP数据交换 

在两个SCTP主机间的正常数据交换。SCTP主机发送SACK块，用来确认每一个收到的SCTP包。因为SACK能完整地描述接收端的状态，因此,依据SACK,发送端能做出重传判决。SCTP支持类似于TCP中的快速重传和time-out重传算法。 

对于数据包丢失发现，SCTP和TCP采用截然不同的机制：当TCP发现接收序号有缺口时，会等到该缺口被填上后，才发送序列号高于丢失数据包的数据。然而，SCTP即使发现接收序号有缺口或顺序错乱，仍会发送后面的数据。 

3.3 SCTP关闭关联 

作 为面向连接的传输协议，SCTP也运用三路握手来关闭一个关联，但与TCP有一点不同：一个TCP终端在“关联关闭”的过程中能够保持连接开启，并从对端 接收新的数据，而SCTP不支持TCP的这种“半关闭”状态。 1. 主机A发出“关闭”（SHUTDOWN）块来终止与主机B的关联，主机A进入“SHUTDOWN- PENDING”状态，对应的动作是：不再接受上层应用的数据，只发送队列中剩余的数据，进入“SHUTDOWN-SENT”状态。

2. 主机B一旦接收到“关闭”块，就进入“SHUTDOWN-RECEIVED”状态，同主机A一样，不再接受上层应用的数据，只发送队列中剩余的数据。 

3. 主机A再次发送“关闭”块，通知主机 B所发送的剩余数据已到达，并且重申了关联正在关闭。 

4. 当第二次收到“关闭”块时，主机B发送“确认关闭”块。 

5. 主机A随后发送“关闭结束”块，完成本次关联的关闭。 

4 结束语 

SCTP 是为传输信令业务流而开发的，但它所具有的一些优于TCP的先进协议机制，如选择性确认、快速重传、无序递交等，使它又满足高性能传输的需求，这会给它带 来更为宽广的应用需求。目前，已有各种操作系统支持SCTP, 如Linux、AIX、Solaris、Windows、FressBSD。在不同协议实现间的互操作性测试的成功，揭示着SCTP正走向商业产品之路。 

IEFT正在致力于SCTP进一步的修改，使其更能满足下一代应用的需求，例如支持IPv6地址，解决对端对于IPv6的site-local、link-local地址无连通性的问题，以及在已存在的关联中动态地增加或删除IP地址而无需重启该关联。 

此外，在第三代移动通信中，SCTP可作为信令承载层的备选方案之一，它的应用及其性能评估也有待研究。

